<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="java，集合框架," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="映射表（map）数据结构的设计由来通常，我们知道某些键的信息，并想要查找与之对应的元素。映射表（map）数据结构就是为此设计的。映射表用来存放键/值对。如果提供了键，就能够查找到值。例如，有一张关于员工信息的记录表，键为员工ID，值为Employee对象。
Java类库为映射表提供了两个通用的实现：HashMap 和 TreeMap。这两个类都实现了Map接口。">
<meta property="og:type" content="article">
<meta property="og:title" content="接口Map">
<meta property="og:url" content="https://brandon-winterfell.github.io/2017/03/16/接口Map/index.html">
<meta property="og:site_name" content="Brandon-Winterfell's Blog">
<meta property="og:description" content="映射表（map）数据结构的设计由来通常，我们知道某些键的信息，并想要查找与之对应的元素。映射表（map）数据结构就是为此设计的。映射表用来存放键/值对。如果提供了键，就能够查找到值。例如，有一张关于员工信息的记录表，键为员工ID，值为Employee对象。
Java类库为映射表提供了两个通用的实现：HashMap 和 TreeMap。这两个类都实现了Map接口。">
<meta property="og:image" content="https://brandon-winterfell.github.io/images/map.gif">
<meta property="og:updated_time" content="2017-03-16T06:25:28.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="接口Map">
<meta name="twitter:description" content="映射表（map）数据结构的设计由来通常，我们知道某些键的信息，并想要查找与之对应的元素。映射表（map）数据结构就是为此设计的。映射表用来存放键/值对。如果提供了键，就能够查找到值。例如，有一张关于员工信息的记录表，键为员工ID，值为Employee对象。
Java类库为映射表提供了两个通用的实现：HashMap 和 TreeMap。这两个类都实现了Map接口。">
<meta name="twitter:image" content="https://brandon-winterfell.github.io/images/map.gif">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://brandon-winterfell.github.io/2017/03/16/接口Map/"/>





  <title> 接口Map | Brandon-Winterfell's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?314832464c94b95e6b76a5f064a517cb";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Brandon-Winterfell's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle">闲寂古池旁,青蛙跳进水中央,扑通一声响</p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://brandon-winterfell.github.io/2017/03/16/接口Map/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Brandon-Winterfell">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Brandon-Winterfell's Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Brandon-Winterfell's Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                接口Map
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-16T12:38:29+08:00">
                2017-03-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/16/接口Map/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/16/接口Map/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/03/16/接口Map/" class="leancloud_visitors" data-flag-title="接口Map">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="映射表（map）数据结构的设计由来"><a href="#映射表（map）数据结构的设计由来" class="headerlink" title="映射表（map）数据结构的设计由来"></a>映射表（map）数据结构的设计由来</h3><p>通常，我们知道某些键的信息，并想要查找与之对应的元素。映射表（map）数据结构就是为此设计的。映射表用来存放键/值对。如果提供了键，就能够查找到值。例如，有一张关于员工信息的记录表，键为员工ID，值为Employee对象。</p>
<p>Java类库为映射表提供了两个通用的实现：HashMap 和 TreeMap。这两个类都实现了Map接口。<a id="more"></a></p>
<p>散列映射表（HashMap）对键进行散列，树映射表（TreeMap）用键的整体顺序对元素进行排序，并将其组织成搜索树。散列或比较函数<em>只能作用于键</em>。与键关联的值不能进行散列或比较。</p>
<h3 id="了解Map接口和方法"><a href="#了解Map接口和方法" class="headerlink" title="了解Map接口和方法"></a>了解Map接口和方法</h3><p>Java核心类中有很多预定义的Map类。在介绍具体实现之前，先介绍一下Map接口本身，一遍了解<strong>所有实现的共同点</strong>。（因为接口是一个规范。）Map接口定义了四种类型的方法，每个Map的具体实现都包含这些方法。</p>
<h4 id="覆盖的方法"><a href="#覆盖的方法" class="headerlink" title="覆盖的方法"></a>覆盖的方法</h4><p>我们将这Object的这两个方法覆盖，以正确比较Map对象的等价性。</p>
<ul>
<li>boolean equals(Object o) 比较指定的对象与此映射是否相等。</li>
<li>int hashCode() 返回此映射的哈希码值</li>
</ul>
<h4 id="Map构建的方法"><a href="#Map构建的方法" class="headerlink" title="Map构建的方法"></a>Map构建的方法</h4><p>Map定义了几个用于插入和删除元素的变换方法，可以更改Map内容。</p>
<ul>
<li>void clear() 从此映射中移除所有映射关系（可选操作）</li>
<li>V remove(Object key)如果存在一个键的映射关系，则将其从此映射中移除（可选操作）</li>
<li>V put（K key, V value）将指定的值与此映射中的指定键关联（可选操作）</li>
<li>void putAll(Map&lt;? extend K, ? extends V&gt; m) 从指定映射中将所有映射关系复制到此映射中（可选操作）</li>
</ul>
<h4 id="查看Map的方法"><a href="#查看Map的方法" class="headerlink" title="查看Map的方法"></a>查看Map的方法</h4><p>迭代 Map 中的元素不存在直接了当的方法。如果要查询某个 Map 以了解其哪些元素满足特定查询，或如果要迭代其所有元素（无论原因如何），则您首先需要获取该 Map 的“视图”。映射表（Map）有三种可能的视图，这是一组实现了 Collection 接口对象，或者它的子接口的视图。<br>有3个视图，分别是：键集，值集合(不是集？？ <em>集合与集的关系？</em>)，键/值对集。返回视图的Map方法：使用这些方法返回的对象，您可以遍历Map的元素，还可以删除Map中的元素。</p>
<ul>
<li>Set<k> keySet() 返回此映射中包含的键的Set视图。删除Set中的元素还将删除Map中相应的映射（键和值）</k></li>
<li>Collection<v> values() 返回此映射中包含的值的Collection视图。删除Collection中的元素还将删除Map中相应的映射（键和值）</v></li>
<li>Set<map.entry<k,v>&gt; entrySet() 返回此映射中包含的映射关系的Set视图。Set中的每个元素都是一个Map.Entry对象，可以使用getKey()和getValue()方法（还有一个setValue()方法）访问后者的键元素和值元素。</map.entry<k,v></li>
</ul>
<h4 id="访问元素的方法"><a href="#访问元素的方法" class="headerlink" title="访问元素的方法"></a>访问元素的方法</h4><p>Map通常适合按键（而非按值）进行访问。Map 定义中没有规定这肯定是真的，但通常您可以期望这是真的。例如，您可以期望 containsKey() 方法与 get() 方法一样快。另一方面，containsValue() 方法很可能需要扫描 Map 中的值，因此它的速度可能比较慢。<br>Map访问和测试方法：这些方法检索有关Map内容的信息但不更改Map内容。</p>
<ul>
<li>V get(Object key) 返回指定键所映射的值；如果此映射不包含改键的映射关系，则返回null。</li>
<li>boolean containsKey(Object key) 如果此映射包含指定键的映射关系，则返回true。</li>
<li>boolean containsValue(Object value) 如果此映射将一个或多个键映射到指定值，则返回true。</li>
<li>boolean isEmpty() 如果此映射未包含键-值映射关系，则返回true。</li>
<li>int size() 返回此映射中的键-值映射关系数。</li>
</ul>
<h3 id="核心Map"><a href="#核心Map" class="headerlink" title="核心Map"></a>核心Map</h3><p>Java自带了各种Map类。这些 Map 类可归为三种类型：</p>
<h4 id="通用-Map，用于在应用程序中管理映射，通常在-java-util-程序包中实现"><a href="#通用-Map，用于在应用程序中管理映射，通常在-java-util-程序包中实现" class="headerlink" title="通用 Map，用于在应用程序中管理映射，通常在 java.util 程序包中实现"></a>通用 Map，用于在应用程序中管理映射，通常在 java.util 程序包中实现</h4><ul>
<li>HashMap</li>
<li>Hashtable</li>
<li>Properties</li>
<li>LinkedHashMap</li>
<li>IdentityHashMap</li>
<li>TreeMap</li>
<li>WeakHashMap</li>
<li>ConcurrentHashMap</li>
<li><h4 id="专用-Map，您通常不必亲自创建此类-Map，而是通过某些其他类对其进行访问"><a href="#专用-Map，您通常不必亲自创建此类-Map，而是通过某些其他类对其进行访问" class="headerlink" title="专用 Map，您通常不必亲自创建此类 Map，而是通过某些其他类对其进行访问"></a>专用 Map，您通常不必亲自创建此类 Map，而是通过某些其他类对其进行访问</h4></li>
<li><p>java.util.jar.Attributes</p>
</li>
<li>javax.print.attribute.standard.PrinterStateReasons</li>
<li>java.security.Provider</li>
<li>java.awt.RenderingHints</li>
<li>javax.swing.UIDefaults</li>
</ul>
<h4 id="一个用于帮助实现您自己的-Map-类的抽象类"><a href="#一个用于帮助实现您自己的-Map-类的抽象类" class="headerlink" title="一个用于帮助实现您自己的 Map 类的抽象类"></a>一个用于帮助实现您自己的 Map 类的抽象类</h4><ul>
<li>AbstractMap</li>
</ul>
<h3 id="内部哈希：哈希映射技术"><a href="#内部哈希：哈希映射技术" class="headerlink" title="内部哈希：哈希映射技术"></a>内部哈希：哈希映射技术</h3><p>几乎所有通用 Map 都使用哈希映射。这是一种将元素映射到数组的非常简单的机制，您应了解哈希映射的工作原理，以便充分利用 Map。</p>
<p>哈希映射结构由一个存储元素的内部数组组成。由于内部采用数组存储，因此必然存在一个用于确定任意键访问数组的索引机制。实际上，该机制需要提供一个小于数组大小的整数索引值。该机制称作哈希函数。在 Java 基于哈希的 Map 中，哈希函数将对象转换为一个适合内部数组的整数。您不必为寻找一个易于使用的哈希函数而大伤脑筋： 每个对象都包含一个返回整数值的 hashCode() 方法。要将该值映射到数组，只需将其转换为一个正值，然后在将该值除以数组大小后取余数即可。以下是一个简单的、适用于任何对象的 Java 哈希函数</p>
<p>int hashvalue = Maths.abs(key.hashCode()) % table.length;</p>
<p>（% 二进制运算符（称作模）将左侧的值除以右侧的值，然后返回整数形式的余数。）</p>
<p>实际上，在 1.4 版发布之前，这就是各种基于哈希的 Map 类所使用的哈希函数。但如果您查看一下代码，您将看到</p>
<p>int hashvalue = (key.hashCode() &amp; 0x7FFFFFFF) % table.length;</p>
<p>它实际上是使用更快机制获取正值的同一函数。在 1.4 版中，HashMap 类实现使用一个不同且更复杂的哈希函数，该函数基于 Doug Lea 的 util.concurrent 程序包（稍后我将更详细地再次介绍 Doug Lea 的类）。</p>
<p><img src="/images/map.gif" alt="哈希工作原理"></p>
<p>该哈希工作原理图介绍了哈希映射的基本原理，但我们还没有对其进行详细介绍。我们的哈希函数将任意对象映射到一个数组位置，但如果两个不同的键映射到相同的位置，情况将会如何？ 这是一种必然发生的情况。在哈希映射的术语中，这称作冲突。Map 处理这些冲突的方法是在索引位置处插入一个链接列表，并简单地将元素添加到此链接列表。因此，一个基于哈希的 Map 的基本 put() 方法可能如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public Object put(Object key, Object value) &#123;</div><div class="line">  //我们的内部数组是一个 Entry 对象数组</div><div class="line">  //Entry[] table;</div><div class="line"></div><div class="line">  //获取哈希码，并映射到一个索引</div><div class="line">  int hash = key.hashCode();</div><div class="line">  int index = (hash &amp; 0x7FFFFFFF) % table.length;</div><div class="line"></div><div class="line">  //循环遍历位于 table[index] 处的链接列表，以查明</div><div class="line">  //我们是否拥有此键项 — 如果拥有，则覆盖它</div><div class="line">  for (Entry e = table[index] ; e != null ; e = e.next) &#123;</div><div class="line">    //必须检查键是否相等，原因是不同的键对象</div><div class="line">    //可能拥有相同的哈希</div><div class="line">    if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</div><div class="line">      //这是相同键，覆盖该值</div><div class="line">      //并从该方法返回 old 值</div><div class="line">      Object old = e.value;</div><div class="line">      e.value = value;</div><div class="line">      return old;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  //仍然在此处，因此它是一个新键，只需添加一个新 Entry</div><div class="line">  //Entry 对象包含 key 对象、 value 对象、一个整型的 hash、</div><div class="line">  //和一个指向列表中的下一个 Entry 的 next Entry</div><div class="line"></div><div class="line">  //创建一个指向上一个列表开头的新 Entry，</div><div class="line">  //并将此新 Entry 插入表中</div><div class="line">  Entry e = new Entry(hash, key, value, table[index]);</div><div class="line">  table[index] = e;</div><div class="line"></div><div class="line">  return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果看一下各种基于哈希的 Map 的源代码，您将发现这基本上就是它们的工作原理。此外，还有一些需要进一步考虑的事项，如处理空键和值以及调整内部数组。此处定义的 put() 方法还包含相应 get() 的算法，这是因为插入包括搜索映射索引处的项以查明该键是否已经存在。（即 get() 方法与 put() 方法具有相同的算法，但 get() 不包含插入和覆盖代码。） 使用链接列表并不是解决冲突的唯一方法，某些哈希映射使用另一种“开放式寻址”方案，本文对其不予介绍。</p>
<h3 id="优化-Hasmap"><a href="#优化-Hasmap" class="headerlink" title="优化 Hasmap"></a>优化 Hasmap</h3><p>如果哈希映射的内部数组只包含一个元素，则所有项将映射到此数组位置，从而构成一个较长的链接列表。由于我们的更新和访问使用了对链接列表的线性搜索，而这要比 Map 中的每个数组索引只包含一个对象的情形要慢得多，因此这样做的效率很低。访问或更新链接列表的时间与列表的大小线性相关，而使用哈希函数问或更新数组中的单个元素则与数组大小无关 — 就渐进性质（Big-O 表示法）而言，前者为 O(n)，而后者为 O(1)。因此，使用一个较大的数组而不是让太多的项聚集在太少的数组位置中是有意义的。</p>
<h4 id="调整-Map-实现的大小"><a href="#调整-Map-实现的大小" class="headerlink" title="调整 Map 实现的大小"></a>调整 Map 实现的大小</h4><p>在哈希术语中，内部数组中的每个位置称作“存储桶”(bucket)，而可用的存储桶数（即内部数组的大小）称作容量 (capacity)。为使 Map 对象有效地处理任意数目的项，Map 实现可以调整自身的大小。但调整大小的开销很大。调整大小需要将所有元素重新插入到新数组中，这是因为不同的数组大小意味着对象现在映射到不同的索引值。先前冲突的键可能不再冲突，而先前不冲突的其他键现在可能冲突。这显然表明，如果将 Map 调整得足够大，则可以减少甚至不再需要重新调整大小，这很有可能显著提高速度。</p>
<h4 id="使用负载因子"><a href="#使用负载因子" class="headerlink" title="使用负载因子"></a>使用负载因子</h4><p>为确定何时调整大小，而不是对每个存储桶中的链接列表的深度进行记数，基于哈希的 Map 使用一个额外参数并粗略计算存储桶的密度。Map 在调整大小之前，使用名为“负载因子”的参数指示 Map 将承担的“负载”量，即它的负载程度。负载因子、项数（Map 大小）与容量之间的关系简单明了：</p>
<ul>
<li>如果（负载因子）x（容量）&gt;（Map 大小），则调整 Map 大小</li>
</ul>
<p>例如，如果默认负载因子为 0.75，默认容量为 11，则 11 x 0.75 = 8.25，该值向下取整为 8 个元素。因此，如果将第 8 个项添加到此 Map，则该 Map 将自身的大小调整为一个更大的值。相反，要计算避免调整大小所需的初始容量，用将要添加的项数除以负载因子，并向上取整，例如，</p>
<ul>
<li>对于负载因子为 0.75 的 100 个项，应将容量设置为 100/0.75 = 133.33，并将结果向上取整为 134（或取整为 135 以使用奇数）</li>
</ul>
<p>奇数个存储桶使 map 能够通过减少冲突数来提高执行效率。虽然我所做的测试（关联文件中的 并未表明质数可以始终获得更好的效率，但理想情形是容量取质数。1.4 版后的某些 Map（如 HashMap 和 LinkedHashMap，而非 Hashtable 或 IdentityHashMap）使用需要 2 的幂容量的哈希函数，但下一个最高 2 的幂容量由这些 Map 计算，因此您不必亲自计算。</p>
<p>负载因子本身是空间和时间之间的调整折衷。较小的负载因子将占用更多的空间，但将降低冲突的可能性，从而将加快访问和更新的速度。使用大于 0.75 的负载因子可能是不明智的，而使用大于 1.0 的负载因子肯定是不明知的，这是因为这必定会引发一次冲突。使用小于 0.50 的负载因子好处并不大，但只要您有效地调整 Map 的大小，应不会对小负载因子造成性能开销，而只会造成内存开销。但较小的负载因子将意味着如果您未预先调整 Map 的大小，则导致更频繁的调整大小，从而降低性能，因此在调整负载因子时一定要注意这个问题。</p>
<h3 id="选择适当的-Map"><a href="#选择适当的-Map" class="headerlink" title="选择适当的 Map"></a>选择适当的 Map</h3><p>应使用哪种 Map？ 它是否需要同步？ 要获得应用程序的最佳性能，这可能是所面临的两个最重要的问题。当使用通用 Map 时，调整 Map 大小和选择负载因子涵盖了 Map 调整选项。</p>
<p>以下是一个用于获得最佳 Map 性能的简单方法</p>
<ol>
<li><p><strong>将您的所有 Map 变量声明为 Map，而不是任何具体实现，即不要声明为 HashMap 或 Hashtable，或任何其他 Map 类实现。</strong></p>
<p> Map criticalMap = new HashMap(); //好</p>
<p> HashMap criticalMap = new HashMap(); //差</p>
<p> <strong>这使您能够只更改一行代码即可非常轻松地替换任何特定的 Map 实例。</strong></p>
</li>
</ol>
<ol>
<li><p>下载 Doug Lea 的 util.concurrent 程序包 (<a href="http://gee.cs.oswego.edu/dl/classes/EDU/oswego/cs/dl/util/concurrent/intro.html)。将" target="_blank" rel="external">http://gee.cs.oswego.edu/dl/classes/EDU/oswego/cs/dl/util/concurrent/intro.html)。将</a> ConcurrentHashMap 用作默认 Map。当移植到 1.5 版时，将 java.util.concurrent.ConcurrentHashMap 用作您的默认 Map。不要将 ConcurrentHashMap 包装在同步的包装器中，即使它将用于多个线程。使用默认大小和负载因子。</p>
</li>
<li><p>监测您的应用程序。如果发现某个 Map 造成瓶颈，则分析造成瓶颈的原因，并部分或全部更改该 Map 的以下内容：Map 类；Map 大小；负载因子；关键对象 equals() 方法实现。专用的 Map 的基本上都需要特殊用途的定制 Map 实现，否则通用 Map 将实现您所需的性能目标。</p>
</li>
</ol>
<h4 id="Map选择"><a href="#Map选择" class="headerlink" title="Map选择"></a>Map选择</h4><p>也许您曾期望更复杂的考量，而这实际上是否显得太容易？ 好的，让我们慢慢来。首先，您应使用哪种 Map？答案很简单： 不要为您的设计选择任何特定的 Map，除非实际的设计需要指定一个特殊类型的 Map。设计时通常不需要选择具体的 Map 实现。您可能知道自己需要一个 Map，但不知道使用哪种。而这恰恰就是使用 Map 接口的意义所在。直到需要时再选择 Map 实现 — 如果随处使用“Map”声明的变量，则更改应用程序中任何特殊 Map 的 Map 实现只需要更改一行，这是一种开销很少的调整选择。是否要使用默认的 Map 实现？ 我很快将谈到这个问题。</p>
<h4 id="同步Map"><a href="#同步Map" class="headerlink" title="同步Map"></a>同步Map</h4><p>同步与否有何差别？ （对于同步，您既可以使用同步的 Map，也可以使用 Collections.synchronizedMap() 将未同步的 Map 转换为同步的 Map。后者使用“同步的包装器”）这是一个异常复杂的选择，完全取决于您如何根据多线程并发访问和更新使用 Map，同时还需要进行维护方面的考虑。例如，如果您开始时未并发更新特定 Map，但它后来更改为并发更新，情况将如何？ 在这种情况下，很容易在开始时使用一个未同步的 Map，并在后来向应用程序中添加并发更新线程时忘记将此未同步的 Map 更改为同步的 Map。这将使您的应用程序容易崩溃（一种要确定和跟踪的最糟糕的错误）。但如果默认为同步，则将因随之而来的可怕性能而序列化执行多线程应用程序。看起来，我们需要某种决策树来帮助我们正确选择。</p>
<p>Doug Lea 是纽约州立大学奥斯威戈分校计算机科学系的教授。他创建了一组公共领域的程序包（统称 util.concurrent），该程序包包含许多可以简化高性能并行编程的实用程序类。这些类中包含两个 Map，即 ConcurrentReaderHashMap 和 ConcurrentHashMap。这些 Map 实现是线程安全的，并且不需要对并发访问或更新进行同步，同时还适用于大多数需要 Map 的情况。它们还远比同步的 Map（如 Hashtable）或使用同步的包装器更具伸缩性，并且与 HashMap 相比，它们对性能的破坏很小。util.concurrent 程序包构成了 JSR166 的基础；JSR166 已经开发了一个包含在 Java 1.5 版中的并发实用程序，而 Java 1.5 版将把这些 Map 包含在一个新的 java.util.concurrent 程序包中。</p>
<p>所有这一切意味着您不需要一个决策树来决定是使用同步的 Map 还是使用非同步的 Map， 而只需使用 ConcurrentHashMap。当然，在某些情况下，使用 ConcurrentHashMap 并不合适。但这些情况很少见，并且应具体情况具体处理。这就是监测的用途。</p>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>通过 Oracle JDeveloper 可以非常轻松地创建一个用于比较各种 Map 性能的测试类。更重要的是，集成良好的监测器可以在开发过程中快速、轻松地识别性能瓶颈 - 集成到 IDE 中的监测器通常被较频繁地使用，以便帮助构建一个成功的工程。现在，您已经拥有了一个监测器并了解了有关通用 Map 及其性能的基础知识，可以开始运行您自己的测试，以查明您的应用程序是否因 Map 而存在瓶颈以及在何处需要更改所使用的 Map。</p>
<p>以上内容介绍了通用 Map 及其性能的基础知识。当然，有关特定 Map 实现以及如何根据不同的需求使用它们还存在更多复杂和值得关注的事项，这些将在本文第 2 部分中介绍。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java，集合框架/" rel="tag"># java，集合框架</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/02/23/一些链接/" rel="next" title="一些链接">
                <i class="fa fa-chevron-left"></i> 一些链接
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2017/03/16/接口Map/"
           data-title="接口Map" data-url="https://brandon-winterfell.github.io/2017/03/16/接口Map/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="Brandon-Winterfell" />
          <p class="site-author-name" itemprop="name">Brandon-Winterfell</p>
           
              <p class="site-description motion-element" itemprop="description">闲寂古池旁,青蛙跳进水中央,扑通一声响</p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#映射表（map）数据结构的设计由来"><span class="nav-number">1.</span> <span class="nav-text">映射表（map）数据结构的设计由来</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#了解Map接口和方法"><span class="nav-number">2.</span> <span class="nav-text">了解Map接口和方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#覆盖的方法"><span class="nav-number">2.1.</span> <span class="nav-text">覆盖的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Map构建的方法"><span class="nav-number">2.2.</span> <span class="nav-text">Map构建的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查看Map的方法"><span class="nav-number">2.3.</span> <span class="nav-text">查看Map的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#访问元素的方法"><span class="nav-number">2.4.</span> <span class="nav-text">访问元素的方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#核心Map"><span class="nav-number">3.</span> <span class="nav-text">核心Map</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#通用-Map，用于在应用程序中管理映射，通常在-java-util-程序包中实现"><span class="nav-number">3.1.</span> <span class="nav-text">通用 Map，用于在应用程序中管理映射，通常在 java.util 程序包中实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#专用-Map，您通常不必亲自创建此类-Map，而是通过某些其他类对其进行访问"><span class="nav-number">3.2.</span> <span class="nav-text">专用 Map，您通常不必亲自创建此类 Map，而是通过某些其他类对其进行访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一个用于帮助实现您自己的-Map-类的抽象类"><span class="nav-number">3.3.</span> <span class="nav-text">一个用于帮助实现您自己的 Map 类的抽象类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内部哈希：哈希映射技术"><span class="nav-number">4.</span> <span class="nav-text">内部哈希：哈希映射技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优化-Hasmap"><span class="nav-number">5.</span> <span class="nav-text">优化 Hasmap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#调整-Map-实现的大小"><span class="nav-number">5.1.</span> <span class="nav-text">调整 Map 实现的大小</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用负载因子"><span class="nav-number">5.2.</span> <span class="nav-text">使用负载因子</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#选择适当的-Map"><span class="nav-number">6.</span> <span class="nav-text">选择适当的 Map</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Map选择"><span class="nav-number">6.1.</span> <span class="nav-text">Map选择</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#同步Map"><span class="nav-number">6.2.</span> <span class="nav-text">同步Map</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结束语"><span class="nav-number">7.</span> <span class="nav-text">结束语</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Brandon-Winterfell</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"brandon-winterfell"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  













  
  

  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("k4OHabJDuJ13RNhNkrjU2hrQ-gzGzoHsz", "saH320A6yTLKdnLkDjp9TOta");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  


</body>
</html>
